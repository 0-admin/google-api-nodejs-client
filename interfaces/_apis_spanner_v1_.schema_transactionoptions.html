<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Schema$TransactionOptions | googleapis</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="../assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="../assets/js/search.js" data-base="..">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="../index.html" class="title">googleapis</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-externals" checked />
							<label class="tsd-widget" for="tsd-filter-externals">Externals</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="../globals.html">Globals</a>
				</li>
				<li>
					<a href="../modules/_apis_spanner_v1_.html">&quot;apis/spanner/v1&quot;</a>
				</li>
				<li>
					<a href="_apis_spanner_v1_.schema_transactionoptions.html">Schema$TransactionOptions</a>
				</li>
			</ul>
			<h1>Interface Schema$TransactionOptions</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<section class="tsd-panel tsd-comment">
				<div class="tsd-comment tsd-typography">
					<div class="lead">
						<h1 id="transactions-each-session-can-have-at-most-one-active-transaction-at-a">Transactions   Each session can have at most one active transaction at a</h1>
						<p>time. After the active transaction is completed, the session can immediately
							be re-used for the next transaction. It is not necessary to create a new
							session for each transaction.  # Transaction Modes  Cloud Spanner supports
							two transaction modes:    1. Locking read-write. This type of transaction is
							the only way      to write data into Cloud Spanner. These transactions rely
							on      pessimistic locking and, if necessary, two-phase commit.      Locking
						read-write transactions may abort, requiring the      application to retry.</p>
						<ol start="2">
							<li>Snapshot read-only. This transaction type provides guaranteed
								consistency across several reads, but does not allow      writes. Snapshot
								read-only transactions can be configured to      read at timestamps in the
								past. Snapshot read-only      transactions do not need to be committed.  For
								transactions that only read, snapshot read-only transactions provide simpler
								semantics and are almost always faster. In particular, read-only transactions
								do not take locks, so they do not conflict with read-write transactions. As a
								consequence of not taking locks, they also do not abort, so retry loops are
								not needed.  Transactions may only read/write data in a single database. They
								may, however, read/write data in different tables within that database.  ##
								Locking Read-Write Transactions  Locking transactions may be used to
								atomically read-modify-write data anywhere in a database. This type of
								transaction is externally consistent.  Clients should attempt to minimize the
								amount of time a transaction is active. Faster transactions commit with
								higher probability and cause less contention. Cloud Spanner attempts to keep
								read locks active as long as the transaction continues to do reads, and the
								transaction has not been terminated by Commit or Rollback.  Long periods of
								inactivity at the client may cause Cloud Spanner to release a
								transaction&#39;s locks and abort it.  Reads performed within a transaction
								acquire locks on the data being read. Writes can only be done at commit time,
								after all reads have been completed. Conceptually, a read-write transaction
								consists of zero or more reads or SQL queries followed by Commit. At any time
								before Commit, the client can send a Rollback request to abort the
								transaction.  ### Semantics  Cloud Spanner can commit the transaction if all
								read locks it acquired are still valid at commit time, and it is able to
								acquire write locks for all writes. Cloud Spanner can abort the transaction
								for any reason. If a commit attempt returns <code>ABORTED</code>, Cloud Spanner
								guarantees that the transaction has not modified any user data in Cloud
								Spanner.  Unless the transaction commits, Cloud Spanner makes no guarantees
								about how long the transaction&#39;s locks were held for. It is an error to
								use Cloud Spanner locks for any sort of mutual exclusion other than between
								Cloud Spanner transactions themselves.  ### Retrying Aborted Transactions
								When a transaction aborts, the application can choose to retry the whole
								transaction again. To maximize the chances of successfully committing the
								retry, the client should execute the retry in the same session as the
								original attempt. The original session&#39;s lock priority increases with
								each consecutive abort, meaning that each attempt has a slightly better
								chance of success than the previous.  Under some circumstances (e.g., many
								transactions attempting to modify the same row(s)), a transaction can abort
								many times in a short period before successfully committing. Thus, it is not
								a good idea to cap the number of retries a transaction can attempt; instead,
								it is better to limit the total amount of wall time spent retrying.  ### Idle
								Transactions  A transaction is considered idle if it has no outstanding reads
								or SQL queries and has not started a read or SQL query within the last 10
								seconds. Idle transactions can be aborted by Cloud Spanner so that they
								don&#39;t hold on to locks indefinitely. In that case, the commit will fail
								with error <code>ABORTED</code>.  If this behavior is undesirable, periodically
								executing a simple SQL query in the transaction (e.g., <code>SELECT 1</code>) prevents
								the transaction from becoming idle.  ## Snapshot Read-Only Transactions
								Snapshot read-only transactions provides a simpler method than locking
								read-write transactions for doing several consistent reads. However, this
								type of transaction does not support writes.  Snapshot transactions do not
								take locks. Instead, they work by choosing a Cloud Spanner timestamp, then
								executing all reads at that timestamp. Since they do not acquire locks, they
								do not block concurrent read-write transactions.  Unlike locking read-write
								transactions, snapshot read-only transactions never abort. They can fail if
								the chosen read timestamp is garbage collected; however, the default garbage
								collection policy is generous enough that most applications do not need to
								worry about this in practice.  Snapshot read-only transactions do not need to
								call Commit or Rollback (and in fact are not permitted to do so).  To execute
								a snapshot transaction, the client specifies a timestamp bound, which tells
								Cloud Spanner how to choose a read timestamp.  The types of timestamp bound
								are:    - Strong (the default).   - Bounded staleness.   - Exact staleness.
								If the Cloud Spanner database to be read is geographically distributed, stale
								read-only transactions can execute more quickly than strong or read-write
								transaction, because they are able to execute far from the leader replica.
								Each type of timestamp bound is discussed in detail below.  ### Strong
								Strong reads are guaranteed to see the effects of all transactions that have
								committed before the start of the read. Furthermore, all rows yielded by a
								single read are consistent with each other -- if any part of the read
								observes a transaction, all parts of the read see the transaction.  Strong
								reads are not repeatable: two consecutive strong read-only transactions might
								return inconsistent results if there are concurrent writes. If consistency
								across reads is required, the reads should be executed within a transaction
								or at an exact read timestamp.  See TransactionOptions.ReadOnly.strong.  ###
								Exact Staleness  These timestamp bounds execute reads at a user-specified
								timestamp. Reads at a timestamp are guaranteed to see a consistent prefix of
								the global transaction history: they observe modifications done by all
								transactions with a commit timestamp &lt;= the read timestamp, and observe
								none of the modifications done by transactions with a larger commit
								timestamp. They will block until all conflicting transactions that may be
								assigned commit timestamps &lt;= the read timestamp have finished.  The
								timestamp can either be expressed as an absolute Cloud Spanner commit
								timestamp or a staleness relative to the current time.  These modes do not
								require a &quot;negotiation phase&quot; to pick a timestamp. As a result,
								they execute slightly faster than the equivalent boundedly stale concurrency
								modes. On the other hand, boundedly stale reads usually return fresher
								results.  See TransactionOptions.ReadOnly.read_timestamp and
								TransactionOptions.ReadOnly.exact_staleness.  ### Bounded Staleness  Bounded
								staleness modes allow Cloud Spanner to pick the read timestamp, subject to a
								user-provided staleness bound. Cloud Spanner chooses the newest timestamp
								within the staleness bound that allows execution of the reads at the closest
								available replica without blocking.  All rows yielded are consistent with
								each other -- if any part of the read observes a transaction, all parts of
								the read see the transaction. Boundedly stale reads are not repeatable: two
								stale reads, even if they use the same staleness bound, can execute at
								different timestamps and thus return inconsistent results.  Boundedly stale
								reads execute in two phases: the first phase negotiates a timestamp among all
								replicas needed to serve the read. In the second phase, reads are executed at
								the negotiated timestamp.  As a result of the two phase execution, bounded
								staleness reads are usually a little slower than comparable exact staleness
								reads. However, they are typically able to return fresher results, and are
								more likely to execute at the closest replica.  Because the timestamp
								negotiation requires up-front knowledge of which rows will be read, it can
								only be used with single-use read-only transactions.  See
								TransactionOptions.ReadOnly.max_staleness and
								TransactionOptions.ReadOnly.min_read_timestamp.  ### Old Read Timestamps and
								Garbage Collection  Cloud Spanner continuously garbage collects deleted and
								overwritten data in the background to reclaim storage space. This process is
								known as &quot;version GC&quot;. By default, version GC reclaims versions
								after they are one hour old. Because of this, Cloud Spanner cannot perform
								reads at read timestamps more than one hour in the past. This restriction
								also applies to in-progress reads and/or SQL queries whose timestamp become
								too old while executing. Reads and SQL queries with too-old read timestamps
							fail with the error <code>FAILED_PRECONDITION</code>.</li>
						</ol>
					</div>
				</div>
			</section>
			<section class="tsd-panel tsd-hierarchy">
				<h3>Hierarchy</h3>
				<ul class="tsd-hierarchy">
					<li>
						<span class="target">Schema$TransactionOptions</span>
					</li>
				</ul>
			</section>
			<section class="tsd-panel-group tsd-index-group">
				<h2>Index</h2>
				<section class="tsd-panel tsd-index-panel">
					<div class="tsd-index-content">
						<section class="tsd-index-section ">
							<h3>Properties</h3>
							<ul class="tsd-index-list">
								<li class="tsd-kind-property tsd-parent-kind-interface"><a href="_apis_spanner_v1_.schema_transactionoptions.html#readonly" class="tsd-kind-icon">read<wbr>Only</a></li>
								<li class="tsd-kind-property tsd-parent-kind-interface"><a href="_apis_spanner_v1_.schema_transactionoptions.html#readwrite" class="tsd-kind-icon">read<wbr>Write</a></li>
							</ul>
						</section>
					</div>
				</section>
			</section>
			<section class="tsd-panel-group tsd-member-group ">
				<h2>Properties</h2>
				<section class="tsd-panel tsd-member tsd-kind-property tsd-parent-kind-interface">
					<a name="readonly" class="tsd-anchor"></a>
					<h3>read<wbr>Only</h3>
					<div class="tsd-signature tsd-kind-icon">read<wbr>Only<span class="tsd-signature-symbol">:</span> <a href="_apis_spanner_v1_.schema_readonly.html" class="tsd-signature-type">Schema$ReadOnly</a></div>
					<aside class="tsd-sources">
						<ul>
							<li>Defined in <a href="https://github.com/JustinBeckwith/google-api-nodejs-client/blob/8e742b96/src/apis/spanner/v1.ts#L1446">apis/spanner/v1.ts:1446</a></li>
						</ul>
					</aside>
					<div class="tsd-comment tsd-typography">
						<div class="lead">
							<p>Transaction will not write.  Authorization to begin a read-only transaction
								requires <code>spanner.databases.beginReadOnlyTransaction</code> permission on the
							<code>session</code> resource.</p>
						</div>
					</div>
				</section>
				<section class="tsd-panel tsd-member tsd-kind-property tsd-parent-kind-interface">
					<a name="readwrite" class="tsd-anchor"></a>
					<h3>read<wbr>Write</h3>
					<div class="tsd-signature tsd-kind-icon">read<wbr>Write<span class="tsd-signature-symbol">:</span> <a href="_apis_spanner_v1_.schema_readwrite.html" class="tsd-signature-type">Schema$ReadWrite</a></div>
					<aside class="tsd-sources">
						<ul>
							<li>Defined in <a href="https://github.com/JustinBeckwith/google-api-nodejs-client/blob/8e742b96/src/apis/spanner/v1.ts#L1452">apis/spanner/v1.ts:1452</a></li>
						</ul>
					</aside>
					<div class="tsd-comment tsd-typography">
						<div class="lead">
							<p>Transaction may write.  Authorization to begin a read-write transaction
								requires <code>spanner.databases.beginOrRollbackReadWriteTransaction</code> permission
							on the <code>session</code> resource.</p>
						</div>
					</div>
				</section>
			</section>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="../globals.html"><em>Globals</em></a>
					</li>
					<li class="current tsd-kind-external-module">
						<a href="../modules/_apis_spanner_v1_.html">"apis/spanner/v1"</a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
				</ul>
				<ul class="current">
					<li class="current tsd-kind-interface tsd-parent-kind-external-module">
						<a href="_apis_spanner_v1_.schema_transactionoptions.html" class="tsd-kind-icon">Schema$<wbr>Transaction<wbr>Options</a>
						<ul>
							<li class=" tsd-kind-property tsd-parent-kind-interface">
								<a href="_apis_spanner_v1_.schema_transactionoptions.html#readonly" class="tsd-kind-icon">read<wbr>Only</a>
							</li>
							<li class=" tsd-kind-property tsd-parent-kind-interface">
								<a href="_apis_spanner_v1_.schema_transactionoptions.html#readwrite" class="tsd-kind-icon">read<wbr>Write</a>
							</li>
						</ul>
					</li>
				</ul>
				<ul class="after-current">
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-module"><span class="tsd-kind-icon">Module</span></li>
				<li class="tsd-kind-object-literal"><span class="tsd-kind-icon">Object literal</span></li>
				<li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-index-signature"><span class="tsd-kind-icon">Index signature</span></li>
				<li class="tsd-kind-type-alias"><span class="tsd-kind-icon">Type alias</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-enum"><span class="tsd-kind-icon">Enumeration</span></li>
				<li class="tsd-kind-enum-member"><span class="tsd-kind-icon">Enumeration member</span></li>
				<li class="tsd-kind-property tsd-parent-kind-enum"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-enum"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
				<li class="tsd-kind-interface tsd-has-type-parameter"><span class="tsd-kind-icon">Interface with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-interface"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-interface"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class"><span class="tsd-kind-icon">Accessor</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-class"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="http://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="../assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="../assets/js/search.js"><' + '/script>');</script>
</body>
</html>